# API TRIGGERING MECHANISMS IN ZOPKIT CHATBOT SYSTEM

## OVERVIEW
The ZOPKIT system has a complex API triggering mechanism that directs user interactions to multiple API endpoints depending on user intent, operation type, and data operations.

## 1. API INTEGRATION LAYER SETUP

### File: api_integration.py (Lines 1-30)
**Purpose**: Master API integration layer that substitutes database calls with API endpoint calls
**Code Used**:
```python
GENERIC_API_URL = "http://localhost:5000"
API_TIMEOUT = 10
USE_API_INTEGRATION = True
```

**Triggering Mechanism:**
• **CONDITION**: Successfully importing api_integration.py
• **TRIGGER**: Globally sets USE_API_INTEGRATION = True
• **FALLBACK**: In case of import failure, sets USE_API_INTEGRATION = False and uses direct database

---

## 2. DYNAMIC CHATBOT API DETECTION

### File: dynamic_chatbot.py (Lines 15-37)
**Purpose**: Automatic detection and import of API integration features
**Code Used**:
```python
try: 
    from api_integration import api_insert_document, api_check_supplier_eligibility
    USE_API_INTEGRATION = True
```
logger.info("✅ API Integration layer loaded - will use API endpoints")
except ImportError:
    USE_API_INTEGRATION = False
    logger.warning("⚠️ API Integration layer not available - will use direct database")

**Triggering Logic**:
• **WHEN**: System startup and module initialization
• **HOW**: Try-catch mechanism tries importing API functions
• **RESULT**: Determines global flag that configures routing behavior throughout app

---


## 3. INTENT-BASED API ROUTING

### File: dynamic_chatbot.py (Lines 115-135)
**Purpose**: Directs user requests to relevant processing nodes according to sensed intent
**Code Used**:
```python
def _process_with_ai(self, user_input: str, state: Dict, session_id: str) -> Dict[str, Any]:
    # Direct to Query Node if a query operation
    if state.get("operation_type") == "query" and state.get("user_validated", False):
        return self._process_query_node(user_input, state, session_id)
```

**Triggering Conditions:**
• **TRIGGER 1**: operation_type == "query" → Routes to Query Node API calls
• **TRIGGER 2**: operation_type == "data_entry" → Routes to Data Entry API calls
• **TRIGGER 3**: operation_type == "validation" → Routes to Validation API calls

---

## 4. QUERY NODE API TRIGGERING

### File: dynamic_chatbot.py (Lines 1231-1350)
**Purpose**: Processes natural language queries and transforms them to API calls
**Code Used**:
```python
def _process_query_node(self, user_input: str, state: Dict, session_id: str) -> Dict[str, Any]:
```
# Call the query via API endpoints
api_result = self._query_via_api(collection_name, mongodb_query, query_config)
```

**Triggering Mechanism**:
• **INPUT**: Natural language query (e.g., "show me document ID 68e116d1b88401b56ae6c4ca")
• **PROCESS**: AI translates to MongoDB query format
• **OUTPUT**: Calls _query_via_api() function
• **API CALL**: GET request to http://localhost:5000/api/{collection_name}

**Document ID Detection Triggers**:
• **Pattern 1**: "document id 68e116d1b88401b56ae6c4ca" → Triggers _id query
• **Pattern 2**: "id 68e116d1b88401b56ae6c4ca" → Triggers _id query
• **Pattern 3**: Any 24-character hex string → Triggers _id query

---

## 5. API QUERY EXECUTION ENGINE

### File: dynamic_chatbot.py (Lines 1117-1180)
**Purpose**: Executes API queries with fallback to direct database
**Code Used**:
```python
def _query_via_api(self, collection_name: str, mongodb_query: Dict, query_config: Dict) -> Dict[str, Any]:
    api_url = f"http://localhost:5000/api/{collection_name}"
    response = requests.get(api_url, params=params, timeout=10)
```

**Triggering Flow**:
• **STEP 1**: Constructs API URL based on collection name
• **STEP 2**: Translates MongoDB query to API parameters
• **STEP 3**: Sends HTTP GET request to API endpoint
• **STEP 4**: If API fails, defaults to _query_via_database()

**Parameter Conversion**:
• **ObjectId Handling**: "_id": "68e116d1b88401b56ae6c4ca" → ?_id=68e116d1b88401b56ae6c4ca
• **Field Queries**: {"/employee_id/": "EMP001"} → ?employee_id=EMP001

---
## 6. DATA INSERTION API TRIGGERING

### File: dynamic_chatbot.py (Lines 484-490)
**Purpose**: Directs data insertion through API endpoints
**Code Used**:
```python
# Use API integration or direct database
if USE_API_INTEGRATION:
```
result = api_insert_document(state["current_task"], state["collected_data"])
else:
    result = insert_document(state["current_task"], state["collected_data"])

**Triggering Conditions**:
• **WHEN**: User confirms data entry (utters "yes", "confirm", "save")
• **HOW**: Checks USE_API_INTEGRATION flag
• **API CALL**: POST request to http://localhost:5000/api/{collection_name}

---

## 7. API INTEGRATION LAYER FUNCTIONS

### File: api_integration.py (Lines 650-795)
**Purpose**: Core API integration functions invoked by chatbot
**Code Used**:
```python
def api_insert_document(collection_name: str, document: Dict[str, Any]) -> Dict[str, Any]:
    url = f"{GENERIC_API_URL}/api/{collection_name}"
```
response = requests.post(url, json=document, timeout=API_TIMEOUT)
```

**Triggering Mechanism**:
• **FUNCTION**: api_insert_document() → POST API call
• **FUNCTION**: api_check_supplier_eligibility() → Validation API call
• **FALLBACK**: If API fails, uses direct MongoDB insertion

---

## 8. ENHANCED API CHATBOT INTEGRATION

### File: enhanced_api_chatbot.py (Lines 32-70)
**Purpose**: Server status detection and API availability checking
**Code Used**:
```python
def start_generic_api_server():
    response = requests.get(f"{GENERIC_API_URL}/", timeout=1)
    if response.status_code == 200:
```
logger.info("✅ API server is running on port 5000")
        return True
```

**Triggering Logic**:
• **HEALTH CHECK**: Pings API server on startup
• **AVAILABILITY**: Determines if API routing should be enabled
• **FALLBACK**: Routes to direct database if API unavailable

---

## 9. 49 GENERIC API ENDPOINTS

### File: api_integration.py (Lines 70-350)
**Purpose**: Defines all available API endpoints and their triggering keywords
**Code Used**:
```python
API_ENDPOINTS = {
    "user_registration": {
        "collection": "user_registration",
        "required": ["email", "first_name", "last_name", "password"],
        "keywords": ["user registration", "register user", "sign up", "create account"]
    },
    "supplier_registration": {
        "collection": "supplier_registration"
    }
}
"required": ["company_name", "contact_email", "business_type", "tax_id"],
        "keywords": ["supplier registration", "register supplier", "add supplier"]
    } #. 47 more endpoints
}

**Triggering Keywords**:
• **User Registration**: "register user", "sign up", "create account"
• **Supplier Registration**: "register supplier", "add supplier", "vendor signup"
• **Purchase Order**: "purchase order", "po", "create order", "buy items"
• **Training Registration**: "training registration", "register training", "enroll training"

---

## 10. CHATBOT NLP INTENT DETECTION

### File: api_integration.py (Lines 355-380)
**Purpose**: Intents to identify user intent and map to correct API endpoint
**Code Used**:
```python
def detect_intent(message: str) -> Dict[str, Any]:
    message_lower = message.lower()
    # Check for GET operations
    get_keywords = ["get", "show", "display", "list", "view", "see", "fetch", "retrieve", "find"]
```
is_get = any(keyword in message_lower for keyword in get_keywords)
    
    # Check for POST operations  
    post_keywords = ["create", "add", "register", "submit", "post", "insert", "new", "apply"]
    is_post = any(keyword in message_lower for keyword in post_keywords)
```

**Triggering Logic**:
• **GET Operations**: Keywords like "show", "display", "list" → Triggers GET API calls
• **POST Operations**: Keywords like "create", "add", "register" → Triggers POST API calls
• **Endpoint Matching**: Matches user intent to specific API endpoints based on keywords

---

## API TRIGGERING SUMMARY

**TOTAL API ENDPOINTS**: 49 endpoints covering all business operations
**TRIGGERING METHODS**: 
1. Intent-based routing (Query vs Data Entry)
2. Keyword matching for endpoint selection  
3. Operation type detection (GET vs POST)
4. Automatic fallback to direct database

**KEY TRIGGER POINTS**:
• Line 18 (dynamic_chatbot.py): USE_API_INTEGRATION flag is set
• Line 131 (dynamic_chatbot.py): Query Node API routing
• Line 486 (dynamic_chatbot.py): Data insertion API routing  
• Line 1140 (dynamic_chatbot.py): API query execution  
• Line 680 (api_integration.py): Core API integration functions  

**INTERVIEW TALKING POINTS**:
1. Smart routing between API and database based on availability
2. 49 automated API endpoints with keyword-based triggering
3. Natural language to API parameter mapping
4. Strong error handling with automatic fallbacks
5. Real-time API health monitoring and adaptive routing